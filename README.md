## Competitive programming stuffs
My implementations of data structures and algorithms for competitive programming


### Data Structures 
+ [x] [Fenwick tree](data_structure/bit.cpp)
+ [x] [Disjoint set union](data_structure/dsu.cpp)
+ [x] [Minimum queue](data_structure/min_queue.cpp)
+ [x] [Mo's algorithm](data_structure/mo.cpp)
+ [x] [Segment tree](data_structure/segtree.cpp)
+ [x] [Sparse table](data_structure/sparse_table.cpp)
+ [ ] Treap

### Graph
+ [x] [Dijkstra](graph/dijkstra.cpp)
+ [x] [Floyd-Warshall](graph/floyd.cpp)
+ [x] [Kruskal](graph/kruskal.cpp)
+ [x] [Least common ancestor using binary lifting](graph/lca_binary_lifting.cpp)
+ [x] [Eulerian path](graph/eulerian_path.cpp)

### Math
+ [x] [Discrete logarithm](math/discrete_log.cpp)
+ [x] [Discrete root](math/discrete_root.cpp)
+ [x] [Extended GCD](math/ext_gcd.cpp)
+ [x] [Linear sieve for divisors count](math/linear_divisors0.cpp)
+ [x] [Linear sieve for divisors sum](math/linear_divisors1.cpp)
+ [x] [Linear sieve for Euler's totient function](math/linear_phi.cpp)
+ [x] [Linear Eratosthenes sieve](math/linear_sieve.cpp)
+ [x] [Least prime factor](math/lpf.cpp)
+ [x] [Matrix exponentiation](math/matrix_expo.cpp)
+ [x] [Euler's totient function](math/phi.cpp)
+ [x] [Pollard's Rho 128 bits](math/pollard_rho_128bits.cpp)
+ [x] [Pollard's Rho](math/pollard_rho.cpp)
+ [x] [Primitive root](math/primitive_root.cpp)
+ [x] [Rabinâ€“Miller primality test](math/rabin_miller.cpp)
+ [x] [Segmented sieve](math/segmented_sieve.cpp)

### String
+ [x] [Prefix function](string/prefix_function.cpp)
+ [x] [Z algorithm](string/z.cpp)
+ [ ] Trie
+ [ ] Knuth-Morris-Pratt
+ [ ] Aho-Corasick
+ [ ] Suffix tree
+ [ ] Suffix array
